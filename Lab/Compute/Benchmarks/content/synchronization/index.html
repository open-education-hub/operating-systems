<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-Lab/Compute/Benchmarks/content/synchronization">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.1.0">
<title data-rh="true">Synchronization | Operating Systems</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="http://localhost//operating-systems/Lab/Compute/Benchmarks/content/synchronization"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Synchronization | Operating Systems"><meta data-rh="true" name="description" content="So far we&#x27;ve used threads and processes without wondering how to &quot;tell&quot; them how to access shared data."><meta data-rh="true" property="og:description" content="So far we&#x27;ve used threads and processes without wondering how to &quot;tell&quot; them how to access shared data."><link data-rh="true" rel="canonical" href="http://localhost//operating-systems/Lab/Compute/Benchmarks/content/synchronization"><link data-rh="true" rel="alternate" href="http://localhost//operating-systems/Lab/Compute/Benchmarks/content/synchronization" hreflang="en"><link data-rh="true" rel="alternate" href="http://localhost//operating-systems/Lab/Compute/Benchmarks/content/synchronization" hreflang="x-default"><link rel="stylesheet" href="/operating-systems/assets/css/styles.17f22a47.css">
<link rel="preload" href="/operating-systems/assets/js/runtime~main.a1c8df68.js" as="script">
<link rel="preload" href="/operating-systems/assets/js/main.f2645913.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="theme.common.skipToMainContent"><a href="#" class="skipToContent_fXgn">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/operating-systems/"><div class="navbar__logo"><img src="/operating-systems/img/logo.svg" alt="Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/operating-systems/img/logo.svg" alt="Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">SO</b></a><a class="navbar__item navbar__link" href="/operating-systems/Introduction">Introduction</a><a class="navbar__item navbar__link" href="/operating-systems/Lecture">Lecture</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/operating-systems/Lab">Lab</a></div><div class="navbar__items navbar__items--right"><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><main class="docMainContainer_gTbr docMainContainerEnhanced_Uz_u"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h1>Synchronization</h1><p>So far we&#x27;ve used threads and processes without wondering how to &quot;tell&quot; them how to access shared data.
Moreover, in order to make threads wait for each other, we simply had the main thread wait for the others to finish all their work.
But what if we want one thread to wait until another one simply performs some specific action after which it resumes its execution?
For this, we need to use some more complex synchronization mechanisms.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="race-conditions">Race Conditions<a class="hash-link" href="#race-conditions" title="Direct link to heading">​</a></h2><p>For example, what if one thread wants to increase a global variable while another one wants to decrease it?
Let&#x27;s say the assembly code for increasing and decreasing the variable looks like the one in the snippet below.</p><div class="language-asm codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-asm codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">increase:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mov eax, [var]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    inc eax</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mov [var], eax</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">decrease:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mov eax, [var]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dec eax</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mov [var], eax</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Imagine both threads executed <code>mov eax, [var]</code> at the same time.
Then each would independently increase its (<strong>non-shared</strong>) <code>eax</code> register.
In the end, the final value of <code>var</code> depends on which thread executes <code>mov [var], eax</code> <em>last</em>.
So it&#x27;s kind of a reversed race.
The thread that runs the slowest &quot;wins&quot; this race and writes the final value of <code>var</code>.
But this is up to the scheduler and is non-deterministic.
Such undefined behaviours can cripple the execution of a program if <code>var</code> is some critical variable.</p><p>Let&#x27;s see this bug in action.
Go to <code>support/race-condition/d/race_condition.d</code>, compile and run the code a few times.
It spawns to threads that do exactly what we&#x27;ve talked about so far: one thread increments <code>var</code> 10 million times, while the other decrements it 10 million times.</p><p>As you can see from running the program, the differences between subsequent runs can be substantial.
To fix this, we must ensure that <strong>only one thread</strong> can execute either <code>var++</code> or <code>var--</code> at any time.
We call these code sections <strong>critical sections</strong>.
A critical section is a piece of code that can only be executed by <strong>one thread</strong> at a time.
So we need some sort of <em>mutual exclusion mechanism</em> so that when one thread runs the critical section, the other has to <strong>wait</strong> before entering it.
This mechanism is called a <strong>mutex</strong>, whose name comes from &quot;mutual exclusion&quot;.</p><p>Go to <code>support/race-condition/d/race_condition_mutex.d</code> and notice the differences between this code and the buggy one.
We now use a <code>Mutex</code> variable which we <code>lock()</code> at the beginning of a critical section and we <code>unlock()</code> at the end.
Generally speaking <code>lock()</code>-ing a mutex makes a thread enter a critical section, while calling <code>unlock()</code> makes the thread leave said critical section.
Therefore, as we said previously, the critical sections in our code are <code>var--</code> and <code>var++</code>.
Run the code multiple times to convince yourself that in the end, the value of <code>var</code> will always be 0.</p><p>Mutexes contain an internal variable which can be either 1 (locked) or 0 (unlocked).
When a thread calls <code>lock()</code>, it attempts to set that variable to 1.
If it was 0, the thread sets it to 1 and proceeds to execute the critical section.
Otherwise, it <strong>suspends its execution</strong> and waits until that variable is set to 0 again.</p><p>When calling <code>unlock()</code>, the internal variable is set to 0 and all waiting threads are woken up to try to acquire the mutex again.
<strong>Be careful:</strong> It is generally considered unsafe and <a href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_lock.html" target="_blank" rel="noopener noreferrer">in many cases undefined behaviour</a> to call <code>unlock()</code> from a different thread than the one that acquired the lock.
So the general workflow should look something like this:</p><div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">within a single thread:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mutex.lock()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // do atomic stuff</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mutex.unlock()</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="synchronization---overhead">Synchronization - Overhead<a class="hash-link" href="#synchronization---overhead" title="Direct link to heading">​</a></h3><blockquote><p>There ain&#x27;t no such thing as a free lunch</p></blockquote><p>This saying is also true for multithreading.
Running threads in parallel is nice and efficient, but synchronization always comes with a penalty: overhead.
Use the <code>time</code> command to record the running times of <code>race_condition</code> and <code>race_condition_mutex</code>.
Notice that those of <code>race_condition_mutex</code> are larger than those of <code>race_condition</code>.</p><p>The cause of this is that now when one thread is executing the critical section, the other has to wait and do nothing.
Waiting means changing its state from RUNNING to WAITING, which brings further overhead from the scheduler.
This latter overhead comes from the <strong>context switch</strong>s that is necessary for a thread to switch its state from RUNNING to WAITING and back.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="practice-wrap-the-whole-for-statements-in-critical-sections">Practice: Wrap the Whole <code>for</code> Statements in Critical Sections<a class="hash-link" href="#practice-wrap-the-whole-for-statements-in-critical-sections" title="Direct link to heading">​</a></h3><p>Move the calls to <code>lock()</code> and <code>unlock()</code> outside the <code>for</code> statements so that the critical sections become the entire statement.
Measure the new time spent by the code and compare it with the execution times recorded when the critical sections were made up of only <code>var--</code> and <code>var++</code>.</p><p><a href="/operating-systems/Lab/Compute/Benchmarks/quiz/coarse-vs-granular-critical-section">Quiz</a></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="atomics">Atomics<a class="hash-link" href="#atomics" title="Direct link to heading">​</a></h2><p>So now we know how to use mutexes.
And we know that mutexes work by using an internal variable that can be either 1 (locked) or 0 (unlocked).
But how does <code>lock()</code> actually set that variable to 1?
How does it avoid a race condition in case another thread also wants to set it to 1?</p><p>We need a guarantee that anyone &quot;touching&quot; that variable does so &quot;within its own critical section&quot;.
But now we need a critical section to implement a critical section...
To solve this circular problem, we make use of a very common <em>Deus ex Machina</em>: <strong>hardware support</strong>.</p><p>Modern processors are capable of <em>atomically</em> accessing data, either for reads or writes.
An atomic action is and indivisible sequence of operations that a thread runs without interference from others.
Concretely, before initiating an atomic transfer on one of its data buses, the CPU first makes sure all other transfers have ended, then <strong>locks</strong> the data bus by stalling all cores attempting to transfer data on it.
This way, one thread obtains <strong>exclusive</strong> access to the data bus while accessing data.
As a side note, the critical sections in <code>support/race-condition/race_condition_mutex.d</code> are also atomic once they are wrapped between calls to <code>lock()</code> and <code>unlock()</code>.</p><p>As with every hardware feature, the <code>x86</code> ISA exposes an instruction for atomic operations.
In particular this instruction is a <strong>prefix</strong>, called <code>lock</code>.
It makes the instruction that follows it run atomically.
The <code>lock</code> prefix ensures that the core performing the instruction has exclusive ownership of the cache line from where the data is transfered for the entire operation.
This is how the increment is made into an indivisible unit.</p><p>For example, <code>inc dword [x]</code> can be made atomic like so: <code>lock inc dword [x]</code>.
You can play with the <code>lock</code> prefix <a href="/operating-systems/Lab/Compute/Benchmarks/content/arena#atomic-assembly">in the Arena</a>.</p><p>Compilers provide support for such hardware-level atomic operations.
GCC exposes <a href="https://gcc.gnu.org/onlinedocs/gcc/_005f_005fatomic-Builtins.html" target="_blank" rel="noopener noreferrer">builtins</a> such as <code>__atomic_load()</code>, <code>__atomic_store()</code>, <code>__atomic_compare_exchange()</code> and many others.
All of them rely on the mechanism described above.</p><p>In D, this functionality is implemented in the <code>core.atomic</code> module.
Go to <code>support/race-condition/d/race_condition_atomic.d</code> and complete the function <code>decrementVar()</code>.
Compile and run the code.
Now measure its running time against the mutex implementations.
It should be somewhere between <code>race_condition.d</code> and <code>race_condition_mutex.d</code>.</p><p>So using the hardware support is more efficient, but it can only be leveraged for simple, individual instructions, such as loads and stores.
And the fact that high-level languages also expose an API for atomic operations shows how useful these operations are for developers.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="semaphores">Semaphores<a class="hash-link" href="#semaphores" title="Direct link to heading">​</a></h2><p>Up to know we&#x27;ve learned how to create critical sections that can be accessed by <strong>only one thread</strong> at a time.
These critical sections revolved around <strong>data</strong>.
Whenever we define a critical section, there is some specific data to which we cannot allow parallel access.
The reason why we can&#x27;t allow it is, in general, data integrity, as we&#x27;ve seen in our examples in <code>support/race-condition/</code></p><p>But what if threads need to count?
Counting is inherently thread-unsafe because it&#x27;s a <em>read-modify-write</em> operation.
We read the counter, increment (modify) it and then write it back.
Think about our example with <a href="/operating-systems/Lab/Compute/Benchmarks/content/processes-threads-apache2"><code>apache2</code></a>
Let&#x27;s say a <code>worker</code> has created a <em>pool</em> of 3 threads.
They are not doing any work initially;
they are in the WAITING state.
As clients initiate connections, these threads are picked up and are used to serve <strong>at most 3</strong> connections at a time.
But the number of connections may be arbitrarily large.
Therefore, we need a way to keep track of it.
When serving a client, a thread should decrement it to inform the others that a connection has been finished.
In short, we need a counter that the dispatcher increments and that worker threads decrement.</p><p>Such a counter could be implemented using a <strong>semaphore</strong>.
For simplicity&#x27;s sake, you can view a semaphore as simply a mutex whose internal variable can take any value and acts like a counter.
When a thread attempts to <code>acquire()</code> a semaphore, it will wait if this counter is less than or equal to 0.
Otherwise, the thread <strong>decrements</strong> the internal counter and the function returns.
The opposite of <code>acquire()</code> is <code>release()</code>, which increases the internal counter by a given value (by default 1).</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="practice-apache2-simulator---semaphore">Practice: <code>apache2</code> Simulator - Semaphore<a class="hash-link" href="#practice-apache2-simulator---semaphore" title="Direct link to heading">​</a></h3><p>Go to <code>support/apache2-simulator/apache2_simulator_semaphore.py</code>.
In the <code>main()</code> function we create a semaphore which we increment (<code>release()</code>) upon every new message.
Each thread decrements (<code>acquire()</code>) this semaphore to signal that it wants to retrieve a message from the list.
The retrieval means modifying a data structure, which is a critical section, so we use a <strong>separate</strong> mutex for this.
Otherwise, multiple threads could acquire the semaphore at the same time and try to modify the list at the same time.
Not good.</p><p>Locking this mutex (which in Python is called <code>Lock</code>) is done with the following statement: <code>with msg_mutex:</code>
This is a syntactic equivalent to:</p><div class="language-Python codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-Python codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">event.acquire()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">messages.append(msg)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">event.release()</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><a href="/operating-systems/Lab/Compute/Benchmarks/quiz/semaphore-equivalent">Quiz</a></p><p>Since the length of the <code>messages</code> list is simply <code>len(messages)</code>, it may seem a bit redundant to use a semaphore to store essentially the same value.
In the next section, we&#x27;ll look at a more refined mechanism for our use case: <em>condition variables</em>.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="conditions">Conditions<a class="hash-link" href="#conditions" title="Direct link to heading">​</a></h2><p>Another way we can implement our <code>apache2</code> simulator is to use a condition variable.
This one is probably the most intuitive synchronization primitive.
It&#x27;s a means by which a thread can tell another one: &quot;Hey, wake up, <em>this</em> happened!&quot;.
So it&#x27;s a way for threads to notify each other.
For this reason, the main methods associated with conditions are <code>notify()</code> and <code>wait()</code>.
As you might expect, they are complementary:</p><ul><li><code>wait()</code> puts the thread in the WAITING state until it&#x27;s woken up by another one</li><li><code>notify()</code> wakes up one or more <code>wait()</code>-ing threads.
If <code>notify()</code> is called before any thread has called <code>wait()</code>, the first thread that calls it will continue its execution unhindered.</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="practice-apache2-simulator---condition">Practice: <code>apache2</code> Simulator - Condition<a class="hash-link" href="#practice-apache2-simulator---condition" title="Direct link to heading">​</a></h3><p>But this is not all, unfortunately.
Look at the code in <code>support/apache2-simulator/apache2_simulator_condition.py</code>.
See the main thread call <code>notify()</code> once it reads the message.
Notice that this call is within a <code>with event</code>: so it acquires some mutex / semaphore.</p><p><code>acquire()</code> and <code>release()</code> are commonly associated with mutexes or semaphores.
What do they have to do with condition variables?</p><p>Well, a lock <code>Condition</code> variable also stores an inner lock (mutex).
It is this lock that we <code>acquire()</code> and <code>release()</code>.
In fact, the <a href="https://docs.python.org/3/library/threading.html#condition-objects" target="_blank" rel="noopener noreferrer">documentation</a> states we should only call <code>Condition</code> methods with its inner lock taken.</p><p>Why is this necessary?
Take a look at the <code>worker()</code> function.
After <code>wait()</code>-ing (we&#x27;ll explain the need for the loop in a bit), it extracts a message from the message queue.
This operation is <strong>not</strong> atomic, so it must be enclosed within a critical section.
Hence, the lock.</p><p><a href="/operating-systems/Lab/Compute/Benchmarks/quiz/notify-only-with-mutex">Quiz</a></p><p>So now we know we cannot only use a mutex.
The mutex is used to access and modify the <code>messages</code> list atomically.
Now you might be thinking that this code causes a deadlock:</p><div class="language-Python codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-Python codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">with event:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while len(messages) == 0:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        event.wait()</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The thread gets the lock and then, if there are no messages, it switches its state to WAITING.
A classic deadlock, right?
No.
<code>wait()</code> also releases the inner lock of the <code>Condition</code> and being woken up reacquires it.
Neat!
And the <code>while</code> loop that checks if there are any new messages is necessary because <code>wait()</code> can return after an arbitrary long time.
Therefore, it&#x27;s necessary to check for messages again when waking up.</p><p>So now we have both synchronization <strong>and</strong> signalling.
This is what conditions are for, ultimately.</p><p>Now that you understand the concept of synchronization, you should apply it in a broader context.
<a href="/operating-systems/Lab/Compute/Benchmarks/content/arena#synchronization---thread-safe-data-structure">In the Arena</a>, you&#x27;ll find an exercise asking you to make an existing arraylist implementation thread-safe.
Have fun!</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="thread-local-storage-tls">Thread-Local Storage (TLS)<a class="hash-link" href="#thread-local-storage-tls" title="Direct link to heading">​</a></h2><p>First things first: what if we don&#x27;t want data to be shared between threads?
Are we condemned to have to worry about race conditions?
Well, no.</p><p>To protect data from race conditions &quot;by design&quot;, we can place in what&#x27;s called <strong>Thread-Local Storage (TLS)</strong>.
As its name implies, this is a type of storage that is &quot;owned&quot; by individual threads, as opposed to being shared among all threads.
<strong>Do not confuse it with copy-on-write</strong>.
TLS pages are always duplicated when creating a new thread and their contents are re-initialised.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="practice-d---tls-by-default">Practice: D - TLS by Default<a class="hash-link" href="#practice-d---tls-by-default" title="Direct link to heading">​</a></h3><p>Take a look again at <code>support/race-condition/d/race_condition.d</code>, specifically at how <code>var</code> is declared:</p><div class="language-d codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-d codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">__gshared int var;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Have you wondered what the <code>__gshared</code> keyword does?
Well, for memory safety reasons, in D, all variables are by default <strong>not shared</strong> between threads.
We need to specifically ask the language to let us share a variable between threads.
We can do this using either the <code>__gshared</code> or <code>shared</code> keywords.
You&#x27;ve seed <code>shared</code> in <code>support/race-condition/d/race_condition_atomic.d</code>.</p><p>The difference between them is that <code>shared</code> only allows programmers read-modify-write the variable atomically, as we do in <code>support/race-condition/d/race_condition_atomic.d</code>.
Modify the <code>incrementVar()</code> function and increment <code>var</code> like you would any variable: <code>var++</code>.
Try to compile the code.
It fails.
The compiler is smart and tells you what to do instead:</p><div class="language-console codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-console codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Error: read-modify-write operations are not allowed for `shared` variables</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Use `core.atomic.atomicOp!&quot;+=&quot;(var, 1)` instead</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><code>__gshared</code> is a rawer version of <code>shared</code>.
It doesn&#x27;t forbid anything.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="practice-c---tls-on-demand">Practice: C - TLS on Demand<a class="hash-link" href="#practice-c---tls-on-demand" title="Direct link to heading">​</a></h3><p>The perspective of C towards TLS is opposed to that of D: in C/C++ everything is shared by default.
This makes multithreading easier and more lightweight to implement than in D, because synchronization is left entirely up to the developer, at the cost of potential unsafety.</p><p>Of course we can specify that some data belongs to the TLS, by preceding the declaration of a variable with <code>__thread</code> keyword.
First, compile and run the code in <code>support/race-condition/c/race_condition_tls.c</code> a few times.
As expected, the result is different each time.</p><ol><li>Modify the declaration of <code>var</code> and add the <code>__thread</code> keyword to place the variable in the TLS of each thread.
Recompile and run the code a few more times.
You should see that in the end, <code>var</code> is 0.</li></ol><p><a href="/operating-systems/Lab/Compute/Benchmarks/quiz/tls-synchronization">Quiz 1</a></p><p><a href="/operating-systems/Lab/Compute/Benchmarks/quiz/tls-var-copies">Quiz 2</a></p><ol><li><p>Print the address and value of <code>var</code> in each thread.
See that they differ.</p></li><li><p>Modify the value of <code>var</code> in the <code>main()</code> function before calling <code>pthread_create()</code>.
Notice that the value doesn&#x27;t propagate to the other threads.
This is because, upon creating a new thread, its TLS is initialised.</p></li></ol></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#race-conditions" class="table-of-contents__link toc-highlight">Race Conditions</a><ul><li><a href="#synchronization---overhead" class="table-of-contents__link toc-highlight">Synchronization - Overhead</a></li><li><a href="#practice-wrap-the-whole-for-statements-in-critical-sections" class="table-of-contents__link toc-highlight">Practice: Wrap the Whole <code>for</code> Statements in Critical Sections</a></li></ul></li><li><a href="#atomics" class="table-of-contents__link toc-highlight">Atomics</a></li><li><a href="#semaphores" class="table-of-contents__link toc-highlight">Semaphores</a><ul><li><a href="#practice-apache2-simulator---semaphore" class="table-of-contents__link toc-highlight">Practice: <code>apache2</code> Simulator - Semaphore</a></li></ul></li><li><a href="#conditions" class="table-of-contents__link toc-highlight">Conditions</a><ul><li><a href="#practice-apache2-simulator---condition" class="table-of-contents__link toc-highlight">Practice: <code>apache2</code> Simulator - Condition</a></li></ul></li><li><a href="#thread-local-storage-tls" class="table-of-contents__link toc-highlight">Thread-Local Storage (TLS)</a><ul><li><a href="#practice-d---tls-by-default" class="table-of-contents__link toc-highlight">Practice: D - TLS by Default</a></li><li><a href="#practice-c---tls-on-demand" class="table-of-contents__link toc-highlight">Practice: C - TLS on Demand</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://curs.upb.ro" target="_blank" rel="noopener noreferrer" class="footer__link-item">Main site<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://ocw.cs.pub.ro/courses/so" target="_blank" rel="noopener noreferrer" class="footer__link-item">OCW<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://www.facebook.com/sisteme.de.operare/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Facebook<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 SO Team</div></div></div></footer></div>
<script src="/operating-systems/assets/js/runtime~main.a1c8df68.js"></script>
<script src="/operating-systems/assets/js/main.f2645913.js"></script>
</body>
</html>